# 欢迎来到Grey Script

## 一种高级、容易编写的面向对象的语言

Grey Script是Miniscript的分支，Miniscript是一种现代脚本语言，设计得简洁、简单、易于学习。
如果您了解其他任何编程语言，您几乎可以立刻上手Grey Script。如果你这辈子从来没有写过一行代码，别紧张！Grey Script是最友好、最有趣的入门方式。这比你想象的要容易的多。

**重要：本文档仅仅介绍Grey Script本身，其内部函数是大多数Miniscript应用程序所共有的。有关Grey Script专用的API接口（例如访问计算机、文件等）的详细信息，请查阅手册的其他章节。**

## 干净、清楚的语法

让我们看一个例子，看看Grey Script代码是什么样子的：

```python
s = "Spam"
while s.len < 50
	s = s + ", spam"
end whlie
pirnt s + "and Spam!"
```

Grey Script中的每个语句通常单独出现在一行当中。请注意，行尾没有分号、大括号或者其他标记。
但这里有一个例外情况：如果您想在一行中连接多个语句，只是为了使你的代码更加紧凑的话，可以使用分号分割语句。下面的例子很丑，但是他是符合语法的：

```python
s = "Spam"; while s.len < 50; s = s + ", Spam"; end while

pirnt s + " and spam!"
```
通常该功能很少被使用，但你仍然可以这么写。

## 代码块

如果您习惯于写C系列的派生语言（C、C++、C#等），那么您可能会习惯在代码块首尾看到花括号。但Grey Script不会这样写，其代码块总是以关键字（it、for、while、function等）开头，并以与之匹配的结束语句（end if、end for、end while、end function）结尾。

## 空白和缩进

您可以在代码中的任意位置插入空格和制表符，但您不能分割标识符和关键字（print	与pr int），也不能省略两个标识符或关键字之间的空格（end if正确而endif不行）。当然，引号中的空格或完全按照您的预期放入字符串中。在数字、运算符等元素之间，你可以插入额外的空格。在Grey Script中，以下两行代码完全相同：

```python
x=4*10+2
x = 4 * 10 + 2
```

为了让代码更具可读性，传统的做法是用一个制表符或两个空格缩排代码中的行，但这不是必须的。Grey Script不关心您如何缩进代码，所以您可以选择最适合您的方式。

## 断行

与C派生语言不同，每行的末尾没有分号或其他标点符号来告诉电脑语句已经结束。相反，仅仅凭换行就可以了。但是，如果您需要输入一个超过一行的语句呢？

Grey Script会识别出语句不完整，并在下一行继续，如果最后一个标记（在任何注释之前——如下）是左括号、方括号或者花括号；或者是一个逗号，或者是任何二元运算符（“+”、“*”等等），那么您可以这样做

```python
speech = [
	"Four Score and seven years ago our fathers",
	"brought forth on this continent, a new nation, conceived",
	"in Liberty, and dedicated to the proposition that all",
	"men are created equal."
]
```

这看起来是四行，但在Grey Script眼中只是一条语句。这是因为前三行都用逗号结尾，这告诉Grey Script接下来还有更多的内容。

## 注释

注释是你留给自己的笔记，或者是为其他阅读你代码的人留下的。他们会被Grey Script完全忽略。注释从两个斜杠开始，并延伸至行尾。因此，你可以在单独的一行上进行注释，也可以在语句之后：

```python
// 一个人要走多少路？
x = 6 * 7 //四十二
```

如同缩进一样，注释不是必须的，但写注释可以更好的地帮助你写代码。

## 括号的使用

Grey Script的括号只有三种用途：

1. 使用他们改变你数学表达式的运算顺序：

```python
x = (2+4)*7 //与2+4*7不同
```

2. 在调用函数的时候包裹参数：

```python
print cos(0) //不能简单写成：print cos 0
```

3. 在声明函数时使用他们（参见“函数”一章）。

由于其他编程语言经常要求在一些愚蠢的地方使用括号，所以指出Grey Script中不使用太多括号的地方是有价值的。首先，在if或者while语句的周围不要加入括号（稍后或有更多关于此的内容）。其次，在调用无参数函数是也不用括号（并且要省略）。例如，有一个time函数可以获取程序开始时的秒数。他不需要任何参数，所以您可以不用括号。

``` python
x = time
```

最后，如上所述，当一个函数是语句的第一个元素时，你不需要在其参数周围加上括号。下面的例子是打印十个数字，每个等待一秒钟，然后打印一条信息。注意我们是如何调用print和wait而不带任何括号的（range需要括号）。

```python
for i in range(10,1)
	print i
	wait
end for
print "Boom!"
```

## 局部变量和全局变量

变量是一个与值关联的单词（也称为标识符）。可以将其视作一个存储数据的小盒子。只需为其赋值便可创建一个变量，正如我们在许多例子里面看到的那样：

```python
x = 42
```

此行创建了一个名为“x”的变量（如果它之前从未被声明），并将其赋值为“42”。这会替换之前变量x的值（如果有的话）。

Grey script中的变量是动态类型的，这意味着，你可以把任何类型的数据（详情参见关于数据类型的章节）赋值给任何变量。

变量有他的作用范围。也就是说，一个函数内部的一个名为“x”的变量，与另一个函数内部的另一个名为“x”的变量，没有任何关系。每个变量的作用范围都是当前正在执行的函数。

但是，Grey Script还支持函数外部的代码，就如同我们见过的例子一样。在上下文中，局部变量和全局变量是一样的。换句话说，在函数体之外将42赋值给变量x，这就创建了一个全局变量x，这样的全局变量可以从上下文任何地方调用。

值得注意的是，当上下文有一个与全局变量同名的局部变量时，该标识符始终被解析为局部变量。同样的，函数内部简单的赋值语句始终创建的是一个局部变量，而非全局变量。在确实需要访问全局变量的情况下，有一个globals对象提高这种访问（有关globals更多的信息，请参阅内在函数章节）。

```python
demo = function()
	print x	//打印全局变量x（40）
    x = 2	//创建一个名为x的局部变量，并赋值为2
    print x	//打印局部变量x（2）
    print globals.x	//再次打印全局变量x（40）
    globals.x = 42	//重新给全局变量赋值为42
    print x			//打印局部变量（2）
    print globals.x	//打印全局变量（42）
end function

x = 40	//创建一个全局变量x，并赋值为40
demo	//调用demo函数
```

过度使用全局变量有时会导致很棘手的错误，所以尽量少用，并尽可能依赖局部变量。Grey Script的设计使得这种良好的实践自然发生。

## Grey Script是区分大小写的

大小写在Grey Script中非常重要。print内置函数必须精准输入为print，而不能是Print、PRINT或其他任何形式的变化。此规则同样适用于你定义的任何变量、函数或者类。

虽然你在自己的标识符中如何使用大小写完全取决于你自己的喜好，但一种常见的约定是对类进行首字母大写，但对于变量则使用小写。因此以下代码完全可行：

```python
shape = new Shape //创建一个名为shape的Shpae对象
```

说到约定，大多数情况下你应该避免用下划线开头来命名任何全局变量或者函数名称。以下划线开头的标识符通常由宿主环境用于特殊的“幕后”代码，名字冲突可能导致很多问题。

# 流程控制  
## 循环与分支  

*流程控制*决定了代码如何多次执行，或仅在特定条件下执行。没有它，你的脚本将仅限于从第一行开始，按顺序逐行执行一次，并在最后一行结束后停止。

GreyScript 包含一种分支（条件）结构和两种循环。

### 使用 if 进行分支  
使用 **if_then** 语句来指定某些条件，只有在满足这些条件时才执行后续语句。基本语法是：
```python
if condition then
.....

end if
```
当条件不成立时，GreyScript 会直接跳转到 end if 语句之后。
```python
if x == 42 then
    print "我找到了终极答案！"
end if
```

从 if…then 到 end if 的整组语句被称为一个 if 代码块。

有时，你希望在指定条件不成立时执行其他操作。你可以在 end if 之前使用 else 代码块来指定。
```python
if x == 42 then
    print "我找到了终极答案！"
else
    print "我仍在寻找。"
end if
```
最后，你可以根据需要添加 else-if 代码块来检查其他条件。下面是一个稍实际些的例子，它将数字转换为文字。
```python
if apples == 0 then
    print "你没有苹果。"
else if apples == 1 then
    print "你有一个苹果。"
else if apples > 10 then
    print "你有很多苹果！"
else
    print "你有 " + apples + " 个苹果。"
end if
```

在这种情况下，第一个匹配的条件将执行其代码块。如果所有条件都不匹配，则将运行 else 代码块。

请注意，对于所有这些形式，if、else if、else 和 end if 语句都必须各自独占一行。但是，还有一种“短格式” if 语句，允许你将一个 if 或 if/else 写在一行上，前提是 **then** 代码块只有一条语句，并且 else 代码块（如果你有的话）也只有一条语句。短格式 if 如下所示：
```python
if x == null then x = 1
```
...而短格式 if/else 如下所示：
```python
if x >= 0 then print "正数" else print "负数"
```
请注意，短格式 if 或 if/else **不使用 end if**。此外，无法在 **then** 或 else 代码块中放入多条语句。如果你需要多条语句，请使用标准的多行形式。

### 使用 for 循环

for..in 语句会多次（包括零次）循环执行一个代码块。语法是：
```python
for _变量_ in _列表_
...
end for
```
整个代码块被称为 _for 循环_。在循环的每次迭代中，变量会被赋予指定列表中的一个值。你将在“数据类型”章节中了解更多关于列表的信息，但现在只需知道你可以使用 range 函数轻松创建一个数字列表。

这个例子从 10 倒数到 1，然后发射。
```python
for i in range(10, 1)
    print i + "..."
end for
print "发射！"
```
关于此函数的更多选项，请参阅“内置函数”章节中的 range 函数。

你还可以迭代一个文本字符串来代替列表。在这种情况下，循环变量将按顺序被赋予字符串中的每个字符。

最后，也可以对映射（map）进行迭代。同样，映射将在“数据类型”章节中解释，但请记住，当你对映射使用 **for** 语句时，在循环的每次迭代中，你的循环变量是一个包含 **key** (键) 和 **value** (值) 的小型映射。例如：
```python
m = {1:"一", 2:"二", 3:"三"}
for kv in m
    print "键 " + kv.key + " 的值为 " + kv.value
end for
这将打印出映射中的每个键值对。
```
### 使用 while 循环
在 GreyScript 中循环执行代码的另一种方法是使用 _while 循环_。语法是：
```python
while 条件
    ...
end while
```
只要 _条件_ 为真，就会执行包含的代码。更具体地说，它首先评估条件，如果条件不为真，则直接跳转到 end while。如果条件为真，则执行循环内的代码，然后跳回到 while 语句。这个过程会一直重复，直到条件变为假。

本手册的第一个例子就说明了这一点，在此重复。
```python
s = "span"
while s.len < 50
    s = s + ", span"
end while
print s + " and span!"
```
这段代码通过不断向字符串 (s) 添加更多 "span" 来构建它，只要字符串长度小于 50。一旦长度不再小于 50，循环退出，并打印结果。

### Break 与 Continue
还有两个额外的关键字可以让你提前退出 while 或 for 循环。首先，**break** 语句直接跳出循环，转到 end for 或 end while 之后的下一行。考虑以下代码。
```python
while true // 无限循环！
    if time > 100 then break
end while
```
每当你看到 while true（或等效的 while 1），这就是一个无限循环——除非循环体内有 break 语句。一旦 break 语句执行，我们就直接跳出循环。它对 for 循环的工作方式完全相同。在嵌套循环的情况下，**break 仅跳出最内层的循环**。

**continue** 语句跳过循环体的剩余部分，并继续下一次迭代。这通常用于大型循环中的"紧急退出"情况，即在某些条件下您希望跳过当前迭代直接进入下一次迭代。
```python
for i in range(1,100)
    if i == 42 then continue
    print "正在考虑 " + i + "..."
end for
```
这将打印出数字 1 到 100，但会跳过数字 42。请注意，如果在此示例中简单地将 continue 改为 break，循环将打印数字 1 到 41，然后停止。

## 真值的本质

我们一直在讨论将条件评估为真或假，但没有解释这真正意味着什么。通常您不需要担心这一点，但以下是详细信息。

GreyScript 中的布尔（真/假）值用数字表示。当为 if 和 while 语句评估条件时，值 0（零）被视为假；任何其他值都被视为真。实际上，内置关键字 true 和 false 分别完全等同于数字 1 和 0。

当您使用比较运算符时，如 ==（等于）、!=（不等于）、>（大于）和 <=（小于等于），这些运算符会比较其操作数并得出 1（如果为真）或 0（如果为假）的结果。

有关可应用于数字的更多布尔运算（包括 **and**、**or** 和 **not**），请参阅"数据类型"章节中的"数字"部分。

最后，在需要真值的上下文中——即在 if 和 while 语句中，或作为 **and**、**or** 和 **not** 的操作数——其他数据类型如果为空则被视为假，如果不为空则被视为真。因此，空字符串、列表或映射在这些上下文中等同于 0（零），任何非空字符串、列表或映射等同于 1。特殊值 null 始终被视为假。

# 数据类型  
## 可以存储和操作的内容  

GreyScript 中的变量是动态类型的；您可以在任何变量中存储任何类型的数据。但具体有哪些数据类型呢？在 GreyScript 中，有四种主要数据类型：*数字*、*字符串*、*列表*和*映射*。还有几种其他不太常见的类型，例如函数和 null。其他所有内容，包括类和对象，实际上都是映射的一种特殊形式。

### 数字  

GreyScript 中的所有数值都以标准全精度格式存储（在 C 派生语言中也称为 "doubles"）。数字也用于表示真（1）和假（0）。

数字字面量写作普通数字形式，例如 42、3.1415、-0.24。

您可以在数字上使用以下运算符（其中 \(a\) 和 \(b\) 是数字）。

| a + b    | 加法         | a 和 b 的数值和                 |
|---|---|---|
| a - b    | 减法         | a 和 b 的数值差                 |
| a * b    | 乘法         | a 乘以 b                        |
| a / b    | 除法         | a 除以 b                        |
| a % b    | 取模         | a 除以 b 后的余数               |
| a ^ b    | 幂运算       | a 的 b 次幂                     |
| a and b  | 逻辑与       | a * b，结果限制在 [0,1] 范围内  |
| a or b   | 逻辑或       | a + b - a*b，结果限制在 [0,1] 范围内 |
| not a    | 逻辑非       | 1 - abs(a)，结果限制在 [0,1] 范围内 |
| a = b    | 相等         | 若 a 等于 b 则为 1，否则为 0    |
| a != b   | 不等         | 若 a 不等于 b 则为 1，否则为 0  |
| a > b    | 大于         | 若 a 大于 b 则为 1，否则为 0    |
| a >= b   | 大于或等于   | 若 a 大于或等于 b 则为 1，否则为 0 |
| a < b    | 小于         | 若 a 小于 b 则为 1，否则为 0    |
| a <= b   | 小于或等于   | 若 a 小于或等于 b 则为 1，否则为 0 |

请注意，**and**、**or** 和 **not** 不是函数；它们是运算符，像其他所有运算符一样位于操作数之间（对于 **not** 则位于操作数之前）。

## 字符串

GreyScript 中的文本值以 Unicode 字符字符串的形式存储。代码中的字符串字面量由双引号 (") 括起来。请确保使用普通的直引号，而不是某些文字处理器坚持使用的花哨的弯引号。

如果您的字符串字面量需要包含引号，可以通过键入两次引号来实现。例如：

``` s="如果你不帮助我们，我们会对你 say ""Ni""。" ```

字符串可以使用 + 运算符进行连接。如果您尝试将数字和字符串相加，数字将自动转换为字符串然后进行连接。字符串也可以通过乘以或除以一个数字来进行复制（重复）或缩减为原来的一部分。
```python
s="Spam"*5 // SpamSpamSpamSpamSpam
s=s/2 // SpamSpamSp
```
完整的字符串运算符如下所示；s 和 t 是字符串，n 和 m 是数字。

| 语法        | 操作名称     | 描述                                                                 |
|-------------|--------------|----------------------------------------------------------------------|
| s + t       | 连接         | 将 t 连接到 s 后形成的字符串                                          |
| s - t       | 减法（切除） | 如果 s 以 t 结尾，则返回移除 t 后的 s；否则直接返回 s                 |
| s * n       | 复制         | 重复 n 次（包括 s 的部分片段）                                       |
| s / n       | 除法         | 等同于 s ^ (1/n)                                                    |
| s[n]        | 索引         | 第 n 个字符（所有索引均为 0 起始；负索引表示从末尾倒数）              |
| s[n:]       | 左切片       | 从开始到第 n 个字符（不包括）的 s 子串                               |
| s[:n]       | 右切片       | 从第 n 个字符到末尾的 s 子串                                         |
| s[n:m]      | 切片         | 从第 n 个字符到第 m 个字符（不包括）的 s 子串                        |
| s == t      | 相等         | 如果 s 等于 t 则为 1，否则为 0（所有字符串比较区分大小写）            |
| s != t      | 不等         | 如果 s 不等于 t 则为 1，否则为 0                                     |
| s > t       | 大于         | 如果 s 大于（按字母顺序排在后面）t 则为 1，否则为 0                   |
| s >= t      | 大于或等于   | 如果 s 大于或等于 t 则为 1，否则为 0                                 |
| s < t       | 小于         | 如果 s 小于（按字母顺序排在前面）t 则为 1，否则为 0                   |
| s <= t      | 小于或等于   | 如果 s 小于或等于 t 则为 1，否则为 0                                 |

上表未包含 **and**、**or** 和 **not**，但这些运算符通过布尔强制转换（参见前一章的"真值的本质"）可以很好地处理字符串。在任何布尔上下文中，如果字符串中包含任何字符，则被视为真；如果是空字符串，则被视为假。

同样未列出的是 **isa** 运算符在字符串上的行为。有一个内在类型叫 **string**，对于任何字符串 **s**，**isa string**都返回 **true** (1)。

切片运算符需要一些解释。基本语法是 **s[n:m]**，它获取字符串**s** 从第 **n**个字符开始、到第**m**个字符（不包括m）的子串，其中字符编号从**0**开始。但这个基本语法通过一些巧妙的技巧进行了扩展：

1.  您可以只指定一个索引，省略冒号，以获取单个字符。因此**s[0]**是第一个字符，**s[1]**是第二个，依此类推。
2.  您可以使用负索引，它将从末尾开始计数。所以**s[-1]**是最后一个字符，**s[-2]**是倒数第二个，等等。这适用于任何切片索引。
3.  您可以在双索引形式中省略第一个索引，它将默认为**0**。这是获取字符串前**n**个字符的便捷方法。所以**s[:3]**返回**s**的前3个字符；**s[-3]**返回**s**除了最后三个字符之外的所有字符。
4.  您可以在双索引形式中省略最后一个索引，它将一直继续到字符串的末尾。因此，**s[3:]**跳过前三个字符并返回字符串的其余部分。

这些索引的工作方式带来了许多非常方便的特性。例如，对于从0到**s.len**的任何**n**值,**s[:n]+s[n:]==s**；换句话说，有一个非常自然的语法可以将字符串分成两部分，这是一件相当常见的事情。

最后，请注意字符串是**不可变的**；就像数字一样，您永远无法更改字符串，但可以创建一个_新_字符串并将其赋值给现有变量。以下示例显示了将 "spin" 改为 "spun" 的一种正确方法和一种错误方法。
```python
s="spin"
s=s[:2]+"u"+s[3:] // 正确
s[3]="u" // 不行 (运行时错误 RuntimeError)
```
## 列表

GreyScript 中的第三种基本数据类型是_列表_。这是一个有序的元素集合，可通过从零开始的索引进行访问。列表的每个元素可以是任何类型，包括另一个列表。
您可以通过将元素用方括号括起来并用逗号分隔来定义列表。

`x = [2, 4, 6, 8]`

上面的代码创建了一个包含四个元素的列表并将其赋值给 x。但是，列表元素不必是数字；它们也可以是字符串、列表或映射。这是另一个例子。

`x = [2, "four", [1, 2, 3], {8:"eight"}]`

处理列表与处理字符串非常相似。您可以使用 + 连接两个列表，使用 * 和 / 复制或切割列表，并使用相同的切片语法访问元素或子列表。以下是适用于列表的运算符，其中 \(p\) 和 \(q\) 是列表，\(n\) 和 \(m\) 是数字。

| 语法        | 操作名称     | 描述                                                                 |
|-------------|--------------|----------------------------------------------------------------------|
| p + q       | 连接         | 将 q 连接到 p 后形成的列表                                           |
| p * n       | 复制         | p 重复 n 次（包括 p 的部分片段）                                     |
| p / n       | 除法         | 等同于 p ^ (1/n)                                                    |
| p[n]        | 索引         | p 的第 n 个元素（所有索引均为 0 起始；负索引表示从末尾倒数）         |
| p[:n]       | 左切片       | p 中从开始到第 n 个元素（不包括）的子列表                            |
| p[n:]       | 右切片       | p 中从第 n 个元素到末尾的子列表                                      |
| p[n:m]      | 切片         | p 中从第 n 个元素到第 m 个元素（不包括）的子列表                     |

此外，您可以使用 `x isa list` 来检查任何变量 \(x\) 是否包含列表。

切片运算符的工作方式与字符串完全相同。因此 `p[-1]` 是列表 p 的最后一个元素；`p[3:]` 跳过前三个元素并返回列表的其余部分，依此类推。

然而，有一个重要的区别：列表是**可变的**。您可以通过对任何切片表达式赋值来更改列表的内容，并且无论有多少不同的变量引用该列表，它们都会看到更改。以下示例说明了这一点。

```python
a = [1, 2, 3] // 创建一个列表并赋值给 a
b = a // 将同一个列表赋值给 b
a[-1] = 5 // 将列表的最后一个元素更改为 5
print(b) // 打印: [1, 2, 5]
```
因为 a 和 b 都引用同一个列表，所以对该列表的任何更改（_变化_）都可以从任一变量中看到。

如果您想确保拥有列表的全新副本，而不是共享引用，一个常见的技巧是使用 `[0:]` 制作一个包含整个列表的切片。这会将元素复制到一个新列表中。将以下示例与上一个示例进行比较。
```python
a = [1, 2, 3] // 创建一个列表并赋值给 a
b = a[0:] // 将该列表的副本赋值给 b
a[-1] = 5 // 将第一个列表的最后一个元素更改为 5
print(b) // 打印: [1, 2, 3] (我们的副本没有改变)
```
### 映射

GreyScript 中最后一种基本数据类型是_映射_。映射是一组键值对的集合，其中每个唯一的键映射到某个值。在某些编程环境中，相同的概念被称为_字典_。

使用花括号括起逗号分隔的键值对列表来创建映射。如这里所示，通过冒号分隔键和值来指定每个键值对。

`m = {1:"one", 2:"two", 3:"three"}`

这里创建的映射包含三个键值对，每个键值对将一个数字映射到一个字符串（在本例中恰好是该数字的英文单词）。

映射的键可以是数字或字符串，并且必须是唯一的；如果重复使用某个键，则先前的值会被替换。值可以是任何类型，包括列表或其他映射。映射内的顺序不被保留；for 循环以任意顺序迭代映射。

映射仅支持少量运算符（\(d\) 和 \(e\) 是映射，\(k\) 是键，\(v\) 是值）：

| 语法        | 操作名称     | 描述                                                                 |
|-------------|--------------|----------------------------------------------------------------------|
| d + e       | 连接         | 将映射 e 中的每个 k.v 键值对赋值给 d，形成的新映射 (即 d[k] = v)     |
| d[k]        | 索引         | 获取映射 d 中键 k 关联的值                                           |
| d.k         | 点索引       | 获取映射 d 中（字符串）键 k 关联的值                                 |

有两种方法可以获取和设置映射的成员。第一种是使用方括号索引运算符，就像处理字符串或列表一样，只是在映射的情况下，键可以是字符串也可以是数字。

```python
d = {"yes":"hai", "no":"lie", "maybe":"tabun"}
print(d["maybe"]) // 打印: tabun
d["maybe"] = "kamo"
print(d["maybe"]) // 打印: kamo
```
第二种方法是使用_点索引器_。这仅在键是字符串且是有效标识符的特殊情况下有效：以字母开头，并且仅包含字母、数字和下划线。在这种情况下，您可以将键写在点后面，而不是将其括在方括号和引号中——该键本质上成为语言中的一个标识符。以下示例在功能上等同于上一个示例。

```python
d = {"yes":"hai", "no":"lie", "maybe":"tabun"}
print(d.maybe) // 打印: tabun
d.maybe = "kamo" 
print(d.maybe) // 打印: kamo
```
这种点索引器主要是语法糖，它使访问映射元素更易于读写。但是在映射表示类或对象的情况下存在一些细微差异，这将在下一章中描述。

最后，与其他基本类型一样，有一个表示映射的内在类——在这种情况下是 `map`。因此，对于任何映射（包括任何类或对象，正如您将在下一节中看到的），`x isa map` 将返回 true。

### 类型检查

上面多次提到了 `isa` 运算符。这是在运行时检查您拥有的数据类型的方法。在许多情况下，由于 MiniScript 的自动类型转换，您不需要关心类型。但有时您需要关心。

例如，假设您想创建一个方法，打印其参数并用括号括起来……但如果调用者传入一个列表，那么您希望用逗号连接该列表的元素。您可以使用 `isa` 来实现这一点。
```python
spew = function(x)
if x isa list then x = x.join(",")
print "(" + x + ")"
end function

spew 42 // 打印: (42)
spew [18, 42, "hike!"] // 打印: (18,42,hike!)
```
### 扩展内置类型

四种内置类型——数值、字符串、列表 和 映射——就像您自己的类（我保证您接下来会学到）一样，只是普通的映射。您可以向它们添加新方法，然后使用点语法在普通的数字、字符串、列表和映射上调用这些方法。（唯一的限制是您不能对数字字面量使用点语法。）如果这听起来像天书，请不要担心——这是一个高级功能，大多数用户永远不需要它。

# 函数和类

复杂软件的构建模块

函数本质上是一个执行特定任务的子程序。我们已经见过一些 GreyScript 内置的函数，例如 time、range，甚至 print。还有更多这样的函数，将在下一章中介绍。但编程语言的真正威力来自于定义您自己的函数。

除此之外，随着程序规模和复杂度的增长，将其组织成*类*变得很有用。类基本上是函数和数据的集合，其中类的*对象*共享相同的函数但可以拥有唯一的数据。

## 函数

GreyScript 中的函数是一种特殊的数据类型，与数字、字符串、列表和映射处于同一级别。您可以使用 function 关键字定义函数，将其赋值给一个变量，然后通过该变量调用它，就像内置函数一样。下面是一个例子。
```python
triple = function(n=1)
return n * 3
end function

print triple() // 打印: 3
print triple(5) // 打印: 15
```
这段代码声明了一个将任何给定值乘以三的函数，并将该函数赋值给名为 triple 的变量。然后调用 triple 函数，分别带参数和不带参数。

声明函数的语法是：
```python
function(参数)
...
end function
```
其中**参数**是一个由零个或多个参数组成的逗号分隔列表，每个参数的形式为 **名称** 或 **名称=默认值**。当调用函数时，参数将按位置与函数参数匹配。如果提供的参数少于定义的参数，则剩余的参数将被赋予其默认值——如果该参数未定义默认值，则将其设置为 null。

请注意，function 关键字后的括号是必需的，即使不需要参数——这是 GreyScript 中少数几个会出现空括号的情况之一。

重要的是要理解函数本身也是一种数据。只是每当查找变量的值时，GreyScript 会检查这种特殊的函数数据类型；如果找到，它会调用该函数，而不是返回函数本身。

通常这正是我们想要的，如上例所示。但偶尔您可能想要复制函数引用，而不是调用函数。您可以通过在标识符前加上 @（读作"地址"）来实现。示例：
```python
triple = function(n=1)
return n * 3
end function

x = @triple
print x(5) // 打印: 15
```
这里我们再次声明了一个函数并将其存储在名为 **triple** 的变量中。然后我们将该函数的**地址**复制到另一个名为 **x** 的变量中。此时，我们可以通过 **triple** 或 **x** 两种方式调用该函数，两者做完全相同的事情。如果我们在赋值时省略了 @，GreyScript 会转而计算 **triple** 引用的函数，并将结果 (3) 赋值给 **x**。

这是一个更实际的例子。我们将定义一个名为 **apply** 的函数，可以将给定函数应用于列表的每个元素。然后我们可以通过使用 @ 来引用我们想要应用的函数，在任何列表上调用它。
```python
apply = function(lst, func)
result = lst[0:] // 创建列表的副本
for i in indexes(result)
result[i] = func(result[i]) // 对每个元素应用函数
end for
return result // 返回修改后的结果
end function

print apply([1,2,3], @triple) // 打印: [3,6,9]
```

总结一下，您可以通过简单地使用引用该函数的任何标识符来调用函数。通过在标识符前加上 @，可以避免这种调用，而是引用函数本身。

### 嵌套函数

GreyScript 允许您在函数内部定义函数。这是一个高级功能，大多数用户可能永远不需要，但有时它会派上用场，特别是与上面提到的 "apply" 方法结合使用时。就像任何其他局部值一样，您可能希望避免仅为在一个地方使用的函数而污染全局命名空间。这是一个简单的例子，假设我们已经定义了上面的 **apply** 方法。
```python
DoubleAll = function(list)
f = function(x)
        return x + x
    end function
    return apply(list, @f)
end function
```
在（全局变量）doubleAll 所引用的函数内部，我们定义了另一个函数，并将其赋值给（局部变量）f。然后我们将该函数作为第二个参数传递给 apply 函数（或者更准确地说，传递给 apply 全局变量所引用的函数）。

当您有这样的嵌套函数时，它可以访问包含它的函数的局部变量。就像使用全局变量一样，它可以不加任何前缀地访问这些变量（只要没有同名的局部变量造成冲突）。但是要赋值给外部函数的变量，必须使用特殊标识符 outer。下面是一个例子。

```python
makeList = function(sep)
    counter = 0
    makeItem = function(item)
        outer.counter = counter + 1
        return counter + sep + item
    end function
    return [makeItem("a"), makeItem("b"), makeItem("c")]
end function

print makeList(".")  // 打印: [1.a, 2.b, 3.c]
```
这里，makeList 引用的是外部函数，而 makeItem 是内部（嵌套）函数。请注意 makeList 有一个名为 counter 的局部变量，初始化为 0。但是内部函数既读取该值，又使用 outer.counter 来更新它。仔细研究这段代码，看看是否能弄清楚它会打印什么……然后尝试运行它，看看您是否正确！

再次说明，这种嵌套函数的功能是一项高级特性，初学者可以安全地忽略它。但对于高级用户来说，这是一个值得理解的语言特性。

## 类和对象

GreyScript 通过基于原型的继承支持面向对象编程（_OOP_）。也就是说，在 GreyScript 中，类和对象之间基本上没有区别；即使存在差异，也完全存在于程序员的意图中。

类或对象是一个包含特殊 `__isa` 条目（指向父级/原型）的映射。这是一个您很少需要担心的实现细节，因为它由以下规则自动处理：

1.  当您使用特殊的 `new` 运算符创建映射时，系统会为您设置 `__isa` 成员。
2.  当您在映射中查找标识符时，GreyScript 将遍历 `__isa` 链以查找包含该标识符的映射。返回的值是找到的第一个值。
3.  最后，`isa` 运算符也会遍历 `__isa` 链，如果该链中的任何映射与右侧操作数匹配，则返回 `true`。换句话说，如果 `x` 是 `y` 的任何子类，则 `x isa y` 返回 `true`。

这些简单的规则提供了面向对象编程所需的一切。可以定义一系列“类”作为包含函数和默认数据的映射，这些映射可以根据需要被继承或重写。“对象”只是另一个映射，继承自某个类，通常仅包含自定义数据。

让我们用一个例子来说明。我们将定义一个名为 `Shape` 的类，以及一个名为 `Square` 的子类。
```python
Shape = {}
Shape.sides = 0

Square = new Shape
Square.sides = 4
```

一个基类只是一个普通的映射；在这个例子中，我们添加了一个值为 0 的 `sides` 条目，表示 "sides" 是我们期望每个 `Shape` 都拥有的一项数据。然后我们通过使用 `new Shape` 创建了一个子类，并将其赋值给 `Square`。在 `Square` 中，我们重写了 `sides` 的值（因为所有正方形都应有 4 条边）。

现在让我们再次使用 `new` 来创建 `Square` 类的一个实例。
```python
x = new Square
print x.sides // 打印: 4
```

请注意，为了方便起见，我们使用了传统的 OOP 术语“类”和“实例”，但实际上，这里只有三个映射——`Shape` 是 `Square` 的原型，而 `Square` 是 `x` 的原型。每个映射的 `__isa` 成员都指向其原型，因为我们是用 `new` 创建它们的。

现在让我们向 Shape 类添加一个函数，该函数应该适用于任何形状子类或对象。
```python
Shape.degrees = function()
return 180 * (self.sides - 2)
end function

print x.degrees // 打印: 360
```
这个例子说明了面向对象编程中另一个重要的附加规则：

* *当通过点索引调用函数时，它会接收一个特殊的 `self` 变量，该变量引用调用该函数的对象。

因此在上面的例子中，我们以 `x.degrees` 的方式调用了 `degrees` 函数，这会在 `x` 中（以及通过 `__isa` 链在其原型中）查找名为 "degrees" 的成员。当该函数被调用时，一个名为 `self` 的特殊局部变量会被绑定到 `x` 对象，即搜索链中的第一个映射。这允许类函数访问对象数据。

面向对象编程还有最后一点特殊支持，那就是 `super` 关键字。这是另一个内置变量（类似于 `self`），当你通过点语法调用方法时定义，但是当你通过 `super` 调用另一个方法时，它会在基类上调用该方法，同时保持 `self` 绑定到与当前函数中相同的值。换句话说，`super` 让你可以调用超类方法，即使你已经重写了它。继续前面的例子，假设我们想定义一个 `Square` 的子类，它总是比非魔法形状多 42 度：
```python
MagicSquare = new Square
MagicSquare.degrees = function()
return super.degrees + 42
end function

y = new MagicSquare
print y.degrees // 打印: 402

```

请注意 `MagicSquare.degrees` 函数如何调用 `super.degrees`。这导致 GreyScript 遍历 `__isa` 链，寻找它能找到的 `degrees` 的第一个实现。那将是 `Shape.degrees`，因此它调用该函数，同时 `self` 仍然绑定到 `y`。

## 扩展内置类型

存在代表每种基本数据类型的映射：number、string、list 和 map。这些映射包含了这些类型的内置方法。通过向这些映射之一添加新方法，您可以使用点语法在该类型的值上调用这些新方法。

例如，虽然有内置的字符串方法 `.upper` 和 `.lower` 可以将字符串转换为大写或小写，但没有一个方法可以将字符串首字母大写——即仅将第一个字母转换为大写。但您可以在程序中添加这样的方法，如下所示。
```python
string.copitalized = function()
if self.len < 2 then return self.upper
return self[0].upper + self[1:]
end function

```

这个函数本身相当简单：如果我们的字符串（self）长度小于 2 个字符，就将整个字符串大写；否则将第一个字母大写，并附加其余部分。但是因为我们将这个函数赋值给了 `string.copitalized`，也就是将其添加到了 string 映射中，我们可以在任何字符串上使用点语法调用它。

`print "greyScript".copitalized // 打印: GreyScript`


这种技巧有一个限制。数字与其他数据类型有些不同；GreyScript 不支持在数字字面量上使用点语法。所以

```python
x = 42
x.someMethod
```
可以正常工作（假设您定义了适当的 `number.someMethod` 函数），但是
`42.someMethod`
则不行。

# 内置函数  
*您可以依赖的内建功能*

GreyScript 附带了一套标准的内建（或*内置*）函数。其中许多是全局函数（即，由全局空间中的变量引用）。其他（特别是设计用于字符串、列表和映射的函数）通常通过标识符后的点语法调用。

但实际上，所有使用点语法的内置函数都以这样一种方式编写，即它们也可以作为全局函数调用。因此，例如，您可以通过输入 `s.len` 来获取字符串 **s**的长度，但也可以使用 **len(s)**实现相同的功能。

以下表格列出了标准的内置函数，按它们操作的数据类型划分。请记住，GreyScript 旨在嵌入到某些主机环境（如游戏或应用程序）中。主机通常会添加特定于该环境的额外内置函数。有关这些额外函数的信息，请查阅您的主机环境的文档或帮助材料。

## 数值函数

GreyScript 包含一系列三角函数（全部使用弧度而非角度）、其他数学函数、随机数生成以及将数字转换为字符串的功能。

在下表中，\( x \) 是任意数字，\( i \) 是整数，\( r \) 是弧度值。

| 函数              | 描述                                                                 |
|-------------------|----------------------------------------------------------------------|
| abs(x)            | \( x \) 的绝对值                                                     |
| acos(x)           | \( x \) 的反余弦值，单位为弧度                                       |
| asin(x)           | \( x \) 的反正弦值，单位为弧度                                       |
| atan(y, x=1)      | \( y/x \) 的反正切值，单位为弧度（如果使用可选的 \( x \) 参数，则返回正确的象限） |
| ceil(x)           | 大于或等于 \( x \) 的最小整数（向上取整函数）                          |
| char(i)           | 返回代码点为 I 的 Unicode 字符（参见 string.code 获取逆函数）         |
| cos(r)            | \( r \) 弧度的余弦值                                                 |
| floor(x)          | 小于或等于 \( x \) 的最大整数（向下取整函数）                          |
| log(x, base=10)   | \( x \) 的对数（以给定底数），即满足 base\(^y\) = \( x \) 的值 \( y \) |
| pi                | 3.14159265358979 (圆周率 π)                                          |
| range(x, y=0, step=null) | 返回一个包含从 \( x \) 到 \( y \) 值的列表，步长为 step；step == null 时，如果 \( y > x \) 则步长默认为 1，否则为 -1 |

| round(x, d=0)     | 将 x 四舍五入到 d 位小数                                               |
|-------------------|-----------------------------------------------------------------------|
| rnd(seed=null)    | 如果 seed=null，返回范围 [0,1) 内的随机数；<br>如果 seed != null，使用给定的整数值作为随机数生成器的种子 |
| sign(x)           | x 的符号：如果 x < 0 则为 -1；如果 x == 0 则为 0；如果 x > 0 则为 1     |
| sin(r)            | r 弧度的正弦值                                                        |
| sqrt(x)           | x 的平方根                                                            |
| str(x)            | 将 x 转换为字符串                                                     |
| tan(r)            | r 弧度的正切值                                                        |

## 字符串函数

除了 slice 之外的所有字符串函数都设计为使用点语法在字符串上调用，但也可以作为全局函数调用，将字符串作为第一个参数传入。请注意，字符串是不可变的；所有字符串函数都返回一个_新_字符串，原始字符串保持不变。在下表中，_self_ 指代字符串本身，\( s \) 是另一个字符串参数，\( i \) 是一个整数。

| 函数                               | 描述                                                                 |
|------------------------------------|----------------------------------------------------------------------|
| .code                              | self 第一个字符的 Unicode 代码点（逆函数参见数值函数 char）          |
| .hasIndex(i)                       | 如果 i 在范围 0 到 self.len-1 内则为 1；否则为 0                     |
| .indexes                           | range(0, self.len-1) （返回索引范围列表）                            |
| .indexOf(s, after=null)            | 子字符串 s 在 self 中首次出现的基于 0 的位置，如果未找到则返回 null；可选地从给定位置之后开始搜索 |
| .insert(index, s)                  | 返回在指定位置 index 处插入了字符串 s 的新字符串                     |
| .len                               | self 的长度（字符数）                                                |
| .lower                             | self 的小写版本                                                      |
| .remove(s)                         | 移除了首次出现的子字符串 s（如果有的话）后的 self                    |
| .replace(oldval, newval, maxCount=null) | 返回一个新字符串，其中最多 maxCount 次出现的子字符串 oldval 被替换为 newval（如果未指定 maxCount，则替换所有出现） |
| .upper                             | self 的大写版本                                                      |
| .val                               | 将 self 转换为数字（如果 self 不是有效数字，则返回 0）               |
| .values                            | self 中各个字符组成的列表（例如 "spam".values = ["s", "p", "a", "m"]） |
| slice(s, from, to)                 | 等效于 s[from:to]                                                    |
| .split(delimiter=" ", maxCount=null) | 按给定的分隔符将字符串分割成一个列表，最多 maxCount 个条目（如果未指定 maxCount，则分割为任意大小的列表） |

## 列表函数

除了 slice 之外的所有列表函数都设计为使用点语法在列表上调用，但也可以作为全局函数调用，将列表作为第一个参数传入。列表是可变的；pop、pull、push、shuffle 和 remove 函数会就地修改列表。要将列表用作栈，请使用 push 添加项目，使用 pop 移除项目。要将列表用作队列，请使用 push 添加项目，使用 pull 移除项目。

在下表中，self 是一个列表，i 是一个整数，x 是任何值。

| 函数                               | 描述                                                                 |
|------------------------------------|----------------------------------------------------------------------|
| .hasIndex(i)                       | 如果 i 在范围 0 到 self.len-1 内则为 1；否则为 0                     |
| .indexes                           | range(0, self.len-1) （返回索引范围列表）                            |
| .indexOf(x, after=null)            | 在 self 中首次找到匹配 x 的元素的位置（基于 0），如果未找到则返回 null；可选地从给定位置之后开始搜索 |
| .insert(index, value)              | 在给定索引 index 处将值 value 插入到 self 中（就地修改）             |
| .join(delimiter=' ')               | 使用给定的分隔符连接元素来构建一个字符串                             |
| .len                               | self 的长度（元素数量）                                              |
| .pop                               | 移除并返回 self 的最后一个元素（类似栈操作）                         |
| .pull                              | 移除并返回 self 的第一个元素（类似队列操作）                         |
| .push(x)                           | 将给定值追加到 self 的末尾；常与 pop 或 pull 一起使用                |
| .shuffle                           | 随机重新排列 self 的元素（就地修改）                                 |
| .sort(key=null)                    | 对列表进行就地排序，可选地按给定键的值排序（例如，在映射列表中）     |
| .sum                               | self 中所有数值元素的总和                                            |
| .remove(i)                         | 从 self 中移除索引 i 处的元素（就地修改）                            |
| .replace(oldval, newval, maxCount=null) | 在列表中将最多 maxCount 次出现的 oldval 替换为 newval（就地修改）（如果未指定 maxCount，则替换所有出现） |
| slice(list, from, to)              | 等效于 list[from:to]                                                 |

## 映射函数

映射上的函数与列表上的函数非常相似。映射（像列表一样）是可变的；push、pop、remove 和 shuffle 方法会就地修改映射。您可以使用 push 将映射当作集合使用，它会为给定键的值插入 1（真），而 pop 则返回一个键并将其（及其值）从映射中移除。请记住，映射中键的顺序是未定义的。

在下表中，self 是一个映射，i 是一个整数，x 是任何值。

| 函数                               | 描述                                                                 |
|------------------------------------|----------------------------------------------------------------------|
| .hasIndex(x)                       | 如果 x 是 self 中包含的键则为 1；否则为 0                           |
| .indexes                           | 包含 self 所有键的列表，顺序任意                                     |
| .indexOf(x, after=null)            | self 中第一个映射到值 x 的键，如果没有则返回 null；可选地从给定键之后开始搜索 |
| .len                               | self 的长度（键值对的数量）                                          |
| .pop                               | 从 self 中移除并返回一个任意的键                                     |
| .push(x)                           | 等效于 self[x] = 1 （将键 x 的值设为 1，常用于实现集合）            |
| .remove(x)                         | 从 self 中移除键为 x 的键值对（就地修改）                           |
| .replace(oldval, newval, maxCount=null) | 在映射中将最多 maxCount 次出现的值 oldval 替换为 newval（就地修改）（如果未指定 maxCount，则替换所有出现） |
| .shuffle                           | 随机重新映射键对应的值（随机打乱键值对的对应关系）                   |
| .sum                               | self 中所有数值值的总和                                              |
| .values                            | 包含 self 所有值的列表，顺序任意                                     |

## 系统函数

以下函数涉及 GreyScript 本身的操作，或与主机环境交互。后者（print、time 和 wait）只是准标准函数，因为对它们的支持取决于主机应用程序，因此在某些环境中可能无法使用。

| 函数          | 描述                                                                 |
|---------------|----------------------------------------------------------------------|
| globals       | 对全局变量映射的引用                                                 |
| locals        | 对当前调用帧的局部变量映射的引用                                     |
| print(x)      | 将 x 转换为字符串并打印到某个文本输出流                             |
| time          | 自程序开始执行以来经过的秒数                                         |
| wait(x=1)     | 等待 x 秒后再执行下一条 GreyScript 指令                             |
| yield         | 等待主引擎循环的下一次调用（例如，游戏中的下一帧）                   |

# 示例

## 实现有趣功能的小程序

虽然我们在本手册中已经给出了 GreyScript 代码的简短示例，但本章提供了几个更长、更有趣的示例。所说明的许多任务都来自 RosettaCode，这是一个包含多种语言解决方案的编程挑战在线数据库。您可以到那里将 GreyScript 的解决方案与任何其他语言进行比较；您可能会惊讶地发现 GreyScript 比其他语言更具可读性。

### FizzBuzz

_FizzBuzz_ 是一个标准入门级编程挑战¹。任务很简单：打印数字 1 到 100，_但是：_ 对于 3 的倍数，打印 "Fizz" 而不是数字；对于 5 的倍数，打印 "Buzz" 而不是数字；对于同时是 3 _和_ 5 的倍数的任何数字，打印 "FizzBuzz"。

脚注 1: https://github.com/facebookresearch/FizzBuzz _(注意：原脚注链接似乎指向了不相关的项目，标准的 FizzBuzz 挑战通常参考其他来源)_

显然有很多方法可以解决这个问题；这里是一种。

```python
fizzBuzz = function(n)
for i in range(1, n)
s = "Fizz" * (i % 3 == 0) + "Buzz" * (i % 5 == 0)
if s == "" then s = str(i)
print s
end for
end function

fizzBuzz(100)
```

我们没有硬编码一个从 1 到 100 的循环，而是创建了一个可以 FizzBuzz 到任何数字的函数。在该函数中，唯一巧妙的部分是第 4 行（原文代码中的第 4 行，此处为 `s = "Fizz" * ...` 这行），它利用了 GreyScript 的几个特性。首先，比较运算（例如 `i % 3 == 0` —— 读作 "i mod 3 equals zero"（i 模 3 等于 0））在条件为真时计算结果为 1，为假时结果为 0。其次，您可以将字符串乘以一个数字以重复该字符串相应的次数。这意味着如果您将一个字符串乘以一个条件，您将得到原始字符串（如果条件为真）或空字符串（如果条件为假）。

这使我们能够根据循环计数器是否可被整除来轻松生成 "Fizz"、"Buzz" 和 "FizzBuzz"。第 5 行（原文代码中的第 5 行，此处为 `if s == "" then s = str(i)`）只是在我们没有获得这些字符串之一时填入数字。（测验：您能否重写这一行，使用与第 4 行相同的乘以条件的技巧？）

## 过滤器 (Filter)

这是另一个来自 RosettaCode 的任务：以通用方式从数组中选择特定元素到一个新数组中。作为演示，从一个数组中选择所有偶数。
```python
filter = function(seq, f) // 将序列 seq 过滤，只保留使函数 f 返回真的元素
result = []
for i in seq
    if f(i) then result = result + [i]
end for
return result
end function

isEven = function(x)
return x % 2 == 0
end function

list = [2,3,5,6,8,9]
print filter(list, @isEven) // 打印: [2, 6, 8]
```
这是将任务描述直接转换为 GreyScript 代码的一个相当直接的实现。我们的 `filter` 函数接受一个列表和一个函数，并通过追加每个应用该函数返回真的元素来构建一个新列表。

我们通过创建一个 `isEven` 函数来演示，该函数仅在其参数模 2 等于零（即参数能被 2 整除）时返回真。然后我们将 `@isEven` 传递给 `filter` 函数，以找出给定列表中的所有偶数元素。

## 最大公约数 (Greatest Common Divisor)

这是一个查找能整除两个给定数字的最大数字的函数。各地的中学生很快就要"失业"了。
```python
gcd = function(a, b)
if a == 0 then return b
while b != 0
    newA = b
    b = a % b
    a = newA
end while
return abs(a)
end function

print gcd(-21, 35) // 打印: 7
```

这里使用的算法被称为“寻找最大公约数的欧几里得算法 (Euclidian algorithm)”，非常巧妙。而实际的 GreyScript 代码则很简单。
## 最大元素 (Maximum Element)

GreyScript 没有用于查找列表最大元素的标准内置函数。但您可以使用以下代码轻松自行添加。
```python
max = function(seq)
if seq.len == 0 then return null
maxVal = seq[0]
for item in seq
    if item > maxVal then maxVal = item
end for
return maxVal
end function

print max([5,-2,12,7,0]) // 打印: 12
```

非常简单。第 2 行检查以确保狡猾的用户没有给我们一个空列表；如果是空列表，我们返回 null，因为在这种情况下没有合理的最大值。否则，我们假设第一个元素是最大值，然后遍历列表中的每个元素，保留最大的一个。

请注意，在第 1 行赋值的 **max** 变量位于全局变量空间中，而在第 3 行和第 5 行赋值（然后在第 7 行返回）的 **maxVal** 是该函数的局部变量。这些变量恰巧同名，但彼此无关。从风格上讲，将局部变量命名为 **result** 而不是 **maxVal** 可能更好。但这似乎是一个很好的机会来演示局部变量和全局变量是分开的，即使它们具有相同的名称。

### 标题大小写 (Titlecase)

GreyScript 具有将字符串转换为全大写或全小写字母的内置函数。但是，如果您只想将每个单词的首字母大写，其余字母小写，该怎么办？
```python
titlecase = function(s)
result = ""
for i in s.indexes
    if i == 0 or s[i-1] == " " then
        result = result + s[i].upper
    else
        result = result + s[i].lower
    end if
end for
return result
end function

print titlecase("SO LONG and thanks for all the fish") // 打印: So Long And Thanks For All The Fish
```

我们只是遍历字符串，将字符串中第一个字符或前面是空格的每个字母大写，其余字母小写。
